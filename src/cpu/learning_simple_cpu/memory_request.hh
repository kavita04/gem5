/*
 * Copyright (c) 2017 Jason Lowe-Power
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met: redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer;
 * redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution;
 * neither the name of the copyright holders nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Jason Lowe-Power
 */

#ifndef __CPU_LEARNING_SIMPLE_MEMORY_REQUEST_HH__
#define __CPU_LEARNING_SIMPLE_MEMORY_REQUEST_HH__

#include "config/the_isa.hh"
#include "cpu/simple_thread.hh"

// Forward declarations.
class LearningSimpleCPU;

/**
 * This class encapsulates outstanding memory requests.
 * It handles translation of each request, creating requests/packets,
 * splitting large requests into smaller requests, etc.
 * Later, this can be used for allowing multiple outstanding requests.
 */
class MemoryRequest : public BaseTLB::Translation
{
  private:
    /// CPU that generated this memory request.
    LearningSimpleCPU &cpu;

    /// The thread that is executing this memory instruction
    SimpleThread &thread;

    /// The static instruction associated with this request. This is the
    /// micro-op if this memory operation is part of a macro-op
    StaticInstPtr inst;

    /// Data for writes.
    uint8_t *data;
    uint64_t *res;

    /// The type of request. If not isFetch or isRead then this is a write.
    bool isFetch;
    bool isRead;

    /// True if the one request must be split into multiple e.g., it
    /// crosses the cache line boundary.
    bool isSplit;

    /// Main request and main packet pointers. This holds the request/packet
    /// for the whole request, if it is split into multiple packets to send.
    RequestPtr req;
    PacketPtr pkt;

    /// The fault (or NoFault) generated by the translation of this request.
    Fault fault;

    /// Auxilary packets/requests for split accesses. The low pkt/req is for
    /// part of the request with the lower address
    RequestPtr sreqLow;
    RequestPtr sreqHigh;
    PacketPtr spktLow;
    PacketPtr spktHigh;

    /// The number of request/packets we're waiting for. This is reused for
    /// both translation and sending the pkts to memory.
    int waitingFor;

    /**
     * Gets the port from the CPU and sends the packet over the port.
     * These three functions are split up to make the code more readable.
     */
    void sendFetch();
    void sendData();
    void sendDataSplit();

  public:
    /**
     * Constructor used for reads and writes. For reads, no data or res.
     * This object is usually constructed in the execution context, not the CPU
     */
    MemoryRequest(LearningSimpleCPU &cpu, SimpleThread &thread,
                  StaticInstPtr inst, Addr addr, unsigned int size,
                  Request::Flags flags, uint8_t *data = nullptr,
                  uint64_t *res = nullptr);

    /**
     * Constructor for instruction fetches. Only need an address.
     */
    MemoryRequest(LearningSimpleCPU &cpu, SimpleThread &thread, Addr addr);

    ~MemoryRequest();

    /**
     * Kick of the request to translate this request. At some point, the TLB
     * will call finish below. This function uses the TLB in the thread object
     * to perform the translation. This automatically chooses itb/dtb based on
     * the request type.
     */
    void translate();

    /**
     * Send this request to the memory system. Eventually, the port will get a
     * response and we expect the CPU to deal with this correctly. This uses
     * the CPU's i/d cache ports to send the request.
     */
    void send();

    /**
     * Signal that the translation has been delayed due to a hw page table
     * walk. Needed to implement Translation.
     */
    void markDelayed() override { };

    /**
     * Called by the TLB (or whatever is translating this request) to let us
     * know the translation is done. Needed to implement Translation.
     */
    void finish(const Fault &fault, RequestPtr req,
                ThreadContext *tc, BaseTLB::Mode mode) override;

    /**
     * Called from the port when the packet finishes.
     *
     * @return true if the packet can be accepted, false otherwise.
     */
    bool recvResponse(PacketPtr pkt);

    /**
     * for tracing execution of instructions.
     */
    void trace(Trace::InstRecord *trace);

    /**
     * Getter for the main request.
     */
    RequestPtr getReq() { return req; }

    /**
     * Getter for the main packet.
     */
    PacketPtr getPkt() { return pkt; }

    /**
     * Getter for the instrucion for this request.
     */
    StaticInstPtr getInst() { return inst; }

    /**
     * Getter for the type of instruction.
     */
    bool getIsFetch() { return isFetch; }

    /**
     * Getter for the type of instruction.
     */
    bool getIsRead() { return isRead; }

    /**
     * Getter for the fault. Only valid after translation.
     */
    const Fault& getFault() { return fault; }
};

#endif
